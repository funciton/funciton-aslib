package funciton.net.connectors {		import flash.errors.IllegalOperationError;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.NetStatusEvent;	import flash.net.NetConnection;	import flash.net.SharedObject;	import flash.utils.clearTimeout;	import flash.utils.setTimeout;		import funciton;	import funciton.models.UpstreamServer;	import funciton.utils.Base64;
		public class BaseConnector extends EventDispatcher {				private var $__upstreams:Vector.<UpstreamServer>;		private var $__ncs:Vector.<Object> = new Vector.<Object>();		private var $__processing:Boolean = false;		private var $__failedConnections:uint = 0;		private var $__backupMode:Boolean = false;		private var $__so:SharedObject = SharedObject.getLocal(funciton.__SONAMESPACE__ + "baseConnector", "/");		private var $__nc:NetConnection;		public function BaseConnector(){		}				public function get nc():NetConnection{ return $__nc; }				public function connect(upstreams:Vector.<UpstreamServer>):void{			if(upstreams && !upstreams.length) throw new IllegalOperationError("Upstreams vector can't be empty");						$__backupMode = false;			$__upstreams = upstreams;			if($__nc != null && $__nc.connected) $__nc.close();			$__nc = null;						$__initConnection();		}				public function cancel():void{			if($__processing){				$__removeNCS();				$__processing = false;			}		}				private function $__handleNetStatus(e:NetStatusEvent):void{						switch(e.info.code){				case "NetConnection.Connect.Success":					var nc:NetConnection;										for each(var item:Object in $__ncs){						if(item.nc === e.currentTarget){							clearTimeout(item.timeout);							item.nc.removeEventListener(e.type, arguments.callee);							nc = item.nc;							break;						}else{							$__removeNC(item);						}					}										$__processing = false;					$__nc = nc;					dispatchEvent(new Event(Event.CONNECT));										break;				case "NetConnection.Connect.Failed":				case "NetConnection.Connect.Rejected":				case "NetConnection.Connect.Closed":					$__failedConnection(e);					break;			}		}				private function $__failedConnection(e:Event):void{			for each(var item:Object in $__ncs){				if(item.nc === e.currentTarget){					var SOncs:Object = $__so.data.ncs || {};										if((item.nc as NetConnection).uri != null){						var ncSignature:String = Base64.encode((item.nc as NetConnection).uri);						if(SOncs[ncSignature] == null) SOncs[ncSignature] = {count: 0, lastFailed: 0};						SOncs[ncSignature].count += 1;						SOncs[ncSignature].lastFailed = new Date(Math.max(SOncs[ncSignature].lastFailed, new Date().time));												$__so.data.ncs = SOncs;						$__so.flush();					}															$__removeNC(item);					break;				}			}			++$__failedConnections;			$__checkFails();		}				private function $__ncTimeout(obj:Object):void{			$__removeNC(obj);			++$__failedConnections;			$__checkFails();		}				private function $__checkFails():void{			if($__failedConnections == $__ncs.length && !$__backupMode){				$__backupMode = true;				$__initConnection();			}else{				$__processing = false;				dispatchEvent(new Event(Event.CLOSE));			}		}				protected function $__initConnection():void{			$__removeNCS();			$__failedConnections = 0;			$__processing = true;						var nc:NetConnection;			if($__upstreams == null){				nc = new NetConnection();				nc.addEventListener(NetStatusEvent.NET_STATUS, $__handleNetStatus);				nc.addEventListener(IOErrorEvent.IO_ERROR, $__failedConnection);				$__ncs = new Vector.<Object>([{nc: nc}]);				nc.connect(null);			}else{								var cons:Vector.<UpstreamServer> = ($__upstreams.filter(backupFilter)).sort(weightSorting);				if(!cons.length){					$__checkFails();					return;				}								$__ncs = new Vector.<Object>(cons.length, true);				for(var i:int=0;i<cons.length;++i){					$__ncs[i] = new Object();					$__ncs[i].nc = new NetConnection();					$__ncs[i].nc.addEventListener(NetStatusEvent.NET_STATUS, $__handleNetStatus);					$__ncs[i].nc.addEventListener(IOErrorEvent.IO_ERROR, $__failedConnection);					$__ncs[i].nc.connect((cons[i] as UpstreamServer).uri);					if((cons[i] as UpstreamServer).timeout != -1){						$__ncs[i].timeout = setTimeout($__ncTimeout, (cons[i] as UpstreamServer).timeout, $__ncs[i]);					}				}			}		}				protected function backupFilter(item:UpstreamServer, index:int, vector:Vector.<UpstreamServer>):Boolean{			if(item.uri != null){				var ncSignature:String = Base64.encode(item.uri);				if($__so.data.ncs != null && $__so.data.ncs[ncSignature] != null){					return (($__so.data.ncs[ncSignature].count <= item.max_fails || ($__so.data.ncs[ncSignature].lastFailed - new Date().time) <= item.expires) && item.backup == $__backupMode && !item.down);				}			}						return (item.backup == $__backupMode && !item.down);		}				protected function weightSorting(x:UpstreamServer, y:UpstreamServer):int{			return (x.weight > y.weight) ? -1: (x.weight < y.weight) ? 1: 0;		}				private function $__removeNC(item:Object, index:int = -1, vector:Vector.<Object> = null):void{			if(item.timeout != null) clearTimeout(item.timeout);			if(item.nc.connected) item.nc.close();			item.nc.removeEventListener(NetStatusEvent.NET_STATUS, $__handleNetStatus);			item.nc.removeEventListener(IOErrorEvent.IO_ERROR, $__failedConnection);			if(index != -1 && vector != null) vector[index] = null;		}				private function $__removeNCS():void{			$__ncs.forEach($__removeNC);			$__ncs = new Vector.<Object>();		}	}	}