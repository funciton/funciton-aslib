package funciton.net.connectors {		import flash.errors.IllegalOperationError;	import flash.events.NetStatusEvent;	import flash.net.NetConnection;	import flash.net.SharedObject;	import flash.utils.clearTimeout;	import flash.utils.setTimeout;		import funciton;	import funciton.models.UpstreamServer;	import funciton.utils.Base64;	import funciton.utils.PendingCall;
		public class BaseConnector {				private var $__upstreams:Vector.<UpstreamServer>;		private var $__ncs:Vector.<Object> = new Vector.<Object>();		private var $__processing:Boolean = false;		private var $__failedConnections:uint = 0;		private var $__backupMode:Boolean = false;		private var $__pendingCall:PendingCall;		private var $__so:SharedObject = SharedObject.getLocal("baseConnector", funciton.__SONAMESPACE__);		public function BaseConnector(){		}				public function connect(upstreams:Vector.<UpstreamServer>):PendingCall{			if(upstreams && !upstreams.length) throw new IllegalOperationError("Upstreams vector can't be empty");						$__backupMode = false;			$__upstreams = upstreams;						$__initConnection();						$__pendingCall = new PendingCall();			return $__pendingCall;		}				public function cancel():void{			if($__processing){				$__removeNCS();				$__processing = false;			}		}				private function $__handleNetStatus(e:NetStatusEvent):void{			var item:Object;			switch(e.info.code){				case "NetConnection.Connect.Success":					var nc:NetConnection;					for each(item in $__ncs){						if(item.nc === e.currentTarget){							clearTimeout(item.timeout);							item.nc.removeEventListener(e.type, arguments.callee);							nc = item.nc;							break;						}else{							$__removeNC(item);						}					}					$__processing = false;					$__pendingCall.onResult(nc);					break;				case "NetConnection.Connect.Failed":				case "NetConnection.Connect.Rejected":				case "NetConnection.Connect.Closed":					for each(item in $__ncs){						if(item.nc === e.currentTarget){							var SOncs:Object = $__so.data.ncs || {};														var ncSignature:String = Base64.encode((item.nc as NetConnection).uri);							if(SOncs[ncSignature] == null) SOncs[ncSignature] = {count: 0, lastFailed: 0};							SOncs[ncSignature].count += 1;							SOncs[ncSignature].lastFailed = new Date(Math.max(SOncs[ncSignature].lastFailed, new Date().time));														$__so.data.ncs = SOncs;							$__so.flush();														$__removeNC(item);							break;						}					}					++$__failedConnections;					$__checkFails();					break;			}		}				private function $__ncTimeout(obj:Object):void{			$__removeNC(obj);			++$__failedConnections;			$__checkFails();		}				private function $__checkFails():void{			if($__failedConnections == $__ncs.length && !$__backupMode){				$__backupMode = true;				$__initConnection();			}else{				$__processing = false;				$__pendingCall.onFault();			}		}				protected function $__initConnection():void{			$__removeNCS();			$__failedConnections = 0;			$__processing = true;						var nc:NetConnection;			if($__upstreams == null){				nc = new NetConnection();				nc.addEventListener(NetStatusEvent.NET_STATUS, $__handleNetStatus, false, 0, true);				$__ncs = new Vector.<Object>([{nc: nc}]);				nc.connect(null);			}else{				var cons:Vector.<UpstreamServer> = ($__upstreams.filter(backupFilter)).sort(weightSorting);				if(!cons.length){					$__checkFails();					return;				}								$__ncs = Vector.<Object>(cons.length, true);				for(var i:int=0;i<cons.length;++i){					var obj:Object = new Object();					nc = new NetConnection();					nc.addEventListener(NetStatusEvent.NET_STATUS, $__handleNetStatus, false, 0, true);					obj.nc = nc;					nc.connect((cons[i] as UpstreamServer).uri);					if((cons[i] as UpstreamServer).timeout != -1){						obj.timeout = setTimeout($__ncTimeout, (cons[i] as UpstreamServer).timeout, obj);					}					$__ncs[i] = obj;				}			}		}				protected function backupFilter(item:UpstreamServer, index:int, vector:Vector.<UpstreamServer>):Boolean{			var ncSignature:String = Base64.encode(item.uri);			if($__so.data.ncs != null && $__so.data.ncs[ncSignature] != null){				return ($__so.data.ncs[ncSignature].count <= item.max_fails || ($__so.data.ncs[ncSignature].lastFailed - new Date().time) <= item.expires);			}						return (item.backup == $__backupMode && !item.down);		}				protected function weightSorting(x:UpstreamServer, y:UpstreamServer):int{			return (x.weight > y.weight) ? -1: (x.weight < y.weight) ? 1: 0;		}				private function $__removeNC(item:Object, index:int = -1, vector:Vector.<Object> = null):void{			if(item.timeout != null) clearTimeout(item.timeout);			if(item.nc.connected) item.nc.close();			item.nc.removeEventListener(NetStatusEvent.NET_STATUS, $__handleNetStatus);			if(index != -1 && vector != null) vector[index] = null;		}				private function $__removeNCS():void{			$__ncs.forEach($__removeNC);			$__ncs = new Vector.<Object>();		}	}	}